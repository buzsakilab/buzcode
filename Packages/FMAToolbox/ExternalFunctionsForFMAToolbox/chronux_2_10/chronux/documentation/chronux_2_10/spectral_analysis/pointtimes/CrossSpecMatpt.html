<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of CrossSpecMatpt</title>
  <meta name="keywords" content="CrossSpecMatpt">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html chronux_2_10 --><!-- ../menu.html spectral_analysis --><!-- menu.html pointtimes -->
<h1>CrossSpecMatpt
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [Sc,Cmat,Ctot,Cvec,Cent,f]=CrossSpecMatpt(data,win,T,params) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">

 Multi-taper cross-spectral matrix - another routine, this one allows for multiple trials and channels 
 but does not do confidence intervals. Also this routine always averages
 over trials - point process as times

 Usage:

 [Sc,Cmat,Ctot,Cvec,Cent,f]=CrossSpecMatpt(data,win,T,params)
 Input: 
 Note units have to be consistent. See chronux.m for more information.
       data (as a struct array with dimensions channels x trials) - note
       that times of measurement have to be consistent, we assume all
       times are specified relative to the start time of the trials which
       are taken to be zero.
       win  (duration of non-overlapping window)
       trialduration (since it is not possible to infer trial duration
               from spike times, this is an optional argument. If not specified
               the routine uses the minimum and maximum spike time (across all
               channels and trials) as the window of calculation.) -
               optional
       params: structure with fields tapers, pad, Fs, fpass
       - optional
           tapers : precalculated tapers from dpss or in the one of the following
                    forms: 
                    (1) A numeric vector [TW K] where TW is the
                        time-bandwidth product and K is the number of
                        tapers to be used (less than or equal to
                        2TW-1). 
                    (2) A numeric vector [W T p] where W is the
                        bandwidth, T is the duration of the data and p 
                        is an integer such that 2TW-p tapers are used. In
                        this form there is no default i.e. to specify
                        the bandwidth, you have to specify T and p as
                        well. Note that the units of W and T have to be
                        consistent: if W is in Hz, T must be in seconds
                        and vice versa. Note that these units must also
                        be consistent with the units of params.Fs: W can
                        be in Hz if and only if params.Fs is in Hz.
                        The default is to use form 1 with TW=3 and K=5

            pad            (padding factor for the FFT) - optional (can take values -1,0,1,2...). 
                    -1 corresponds to no padding, 0 corresponds to padding
                    to the next highest power of 2 etc.
                       e.g. For N = 500, if PAD = -1, we do not pad; if PAD = 0, we pad the FFT
                       to 512 points, if pad=1, we pad to 1024 points etc.
                       Defaults to 0.
           Fs   (sampling frequency) - optional. Default 1.
           fpass    (frequency band to be used in the calculation in the form
                                   [fmin fmax])- optional. 
                                   Default all frequencies between 0 and Fs/2
 Output:
       Sc (cross spectral matrix frequency x channels x channels)
       Cmat Coherence matrix frequency x channels x channels
       Ctot Total coherence: SV(1)^2/sum(SV^2) (frequency)
       Cvec leading Eigenvector (frequency x channels)
       Cent A different measure of total coherence: GM/AM of SV^2s
       f (frequencies)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../chronux_2_10/spectral_analysis/helper/dpsschk.html" class="code" title="function [tapers,eigs]=dpsschk(tapers,N,Fs)">dpsschk</a>	Helper function to calculate tapers and, if precalculated tapers are supplied,</li><li><a href="../../../chronux_2_10/spectral_analysis/helper/getfgrid.html" class="code" title="function [f,findx]=getfgrid(Fs,nfft,fpass)">getfgrid</a>	Helper function that gets the frequency grid associated with a given fft based computation</li><li><a href="../../../chronux_2_10/spectral_analysis/helper/getparams.html" class="code" title="function [tapers,pad,Fs,fpass,err,trialave,params]=getparams(params)">getparams</a>	Helper function to convert structure params to variables used by the</li><li><a href="extractdatapt.html" class="code" title="function data=extractdatapt(data,t,offset)">extractdatapt</a>	Extract segements of spike times between t(1) and t(2)</li><li><a href="minmaxsptimes.html" class="code" title="function [mintime, maxtime]=minmaxsptimes(data)">minmaxsptimes</a>	Find the minimum and maximum of the spike times in each channel</li><li><a href="mtfftpt.html" class="code" title="function [J,Msp,Nsp]=mtfftpt(data,tapers,nfft,t,f,findx)">mtfftpt</a>	Multi-taper fourier transform for point process given as times</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Sc,Cmat,Ctot,Cvec,Cent,f]=CrossSpecMatpt(data,win,T,params)</a>
0002 <span class="comment">%</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Multi-taper cross-spectral matrix - another routine, this one allows for multiple trials and channels</span>
0005 <span class="comment">% but does not do confidence intervals. Also this routine always averages</span>
0006 <span class="comment">% over trials - point process as times</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Usage:</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% [Sc,Cmat,Ctot,Cvec,Cent,f]=CrossSpecMatpt(data,win,T,params)</span>
0011 <span class="comment">% Input:</span>
0012 <span class="comment">% Note units have to be consistent. See chronux.m for more information.</span>
0013 <span class="comment">%       data (as a struct array with dimensions channels x trials) - note</span>
0014 <span class="comment">%       that times of measurement have to be consistent, we assume all</span>
0015 <span class="comment">%       times are specified relative to the start time of the trials which</span>
0016 <span class="comment">%       are taken to be zero.</span>
0017 <span class="comment">%       win  (duration of non-overlapping window)</span>
0018 <span class="comment">%       trialduration (since it is not possible to infer trial duration</span>
0019 <span class="comment">%               from spike times, this is an optional argument. If not specified</span>
0020 <span class="comment">%               the routine uses the minimum and maximum spike time (across all</span>
0021 <span class="comment">%               channels and trials) as the window of calculation.) -</span>
0022 <span class="comment">%               optional</span>
0023 <span class="comment">%       params: structure with fields tapers, pad, Fs, fpass</span>
0024 <span class="comment">%       - optional</span>
0025 <span class="comment">%           tapers : precalculated tapers from dpss or in the one of the following</span>
0026 <span class="comment">%                    forms:</span>
0027 <span class="comment">%                    (1) A numeric vector [TW K] where TW is the</span>
0028 <span class="comment">%                        time-bandwidth product and K is the number of</span>
0029 <span class="comment">%                        tapers to be used (less than or equal to</span>
0030 <span class="comment">%                        2TW-1).</span>
0031 <span class="comment">%                    (2) A numeric vector [W T p] where W is the</span>
0032 <span class="comment">%                        bandwidth, T is the duration of the data and p</span>
0033 <span class="comment">%                        is an integer such that 2TW-p tapers are used. In</span>
0034 <span class="comment">%                        this form there is no default i.e. to specify</span>
0035 <span class="comment">%                        the bandwidth, you have to specify T and p as</span>
0036 <span class="comment">%                        well. Note that the units of W and T have to be</span>
0037 <span class="comment">%                        consistent: if W is in Hz, T must be in seconds</span>
0038 <span class="comment">%                        and vice versa. Note that these units must also</span>
0039 <span class="comment">%                        be consistent with the units of params.Fs: W can</span>
0040 <span class="comment">%                        be in Hz if and only if params.Fs is in Hz.</span>
0041 <span class="comment">%                        The default is to use form 1 with TW=3 and K=5</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%            pad            (padding factor for the FFT) - optional (can take values -1,0,1,2...).</span>
0044 <span class="comment">%                    -1 corresponds to no padding, 0 corresponds to padding</span>
0045 <span class="comment">%                    to the next highest power of 2 etc.</span>
0046 <span class="comment">%                       e.g. For N = 500, if PAD = -1, we do not pad; if PAD = 0, we pad the FFT</span>
0047 <span class="comment">%                       to 512 points, if pad=1, we pad to 1024 points etc.</span>
0048 <span class="comment">%                       Defaults to 0.</span>
0049 <span class="comment">%           Fs   (sampling frequency) - optional. Default 1.</span>
0050 <span class="comment">%           fpass    (frequency band to be used in the calculation in the form</span>
0051 <span class="comment">%                                   [fmin fmax])- optional.</span>
0052 <span class="comment">%                                   Default all frequencies between 0 and Fs/2</span>
0053 <span class="comment">% Output:</span>
0054 <span class="comment">%       Sc (cross spectral matrix frequency x channels x channels)</span>
0055 <span class="comment">%       Cmat Coherence matrix frequency x channels x channels</span>
0056 <span class="comment">%       Ctot Total coherence: SV(1)^2/sum(SV^2) (frequency)</span>
0057 <span class="comment">%       Cvec leading Eigenvector (frequency x channels)</span>
0058 <span class="comment">%       Cent A different measure of total coherence: GM/AM of SV^2s</span>
0059 <span class="comment">%       f (frequencies)</span>
0060 d=ndims(data);
0061 <span class="keyword">if</span> size(d,1)==1; error(<span class="string">'Need multiple channels; are you sure your format is channels x trials ?'</span>);<span class="keyword">end</span>;
0062 [C,Ntr]=size(data);
0063 mintime=0;
0064 <span class="keyword">if</span> nargin &lt; 3; [mintime,maxtime]=<a href="minmaxsptimes.html" class="code" title="function [mintime, maxtime]=minmaxsptimes(data)">minmaxsptimes</a>(data);clear mintime;
0065 <span class="keyword">else</span> maxtime=T; <span class="keyword">end</span>;
0066 <span class="keyword">if</span> nargin &lt; 4; params=[]; <span class="keyword">end</span>;
0067 [tapers,pad,Fs,fpass,err,trialave,params]=<a href="../../../chronux_2_10/spectral_analysis/helper/getparams.html" class="code" title="function [tapers,pad,Fs,fpass,err,trialave,params]=getparams(params)">getparams</a>(params);
0068 clear err trialave params
0069 Nwin=round(Fs*win); <span class="comment">% number of samples in window</span>
0070 nfft=max(2^(nextpow2(Nwin)+pad),Nwin);
0071 [f,findx]=<a href="../../../chronux_2_10/spectral_analysis/helper/getfgrid.html" class="code" title="function [f,findx]=getfgrid(Fs,nfft,fpass)">getfgrid</a>(Fs,nfft,fpass); 
0072 tapers=<a href="../../../chronux_2_10/spectral_analysis/helper/dpsschk.html" class="code" title="function [tapers,eigs]=dpsschk(tapers,N,Fs)">dpsschk</a>(tapers,Nwin,Fs); <span class="comment">% check tapers</span>
0073 twin=linspace(0,win,Nwin); <span class="comment">% times of occurrence of &quot;samples&quot; within window - times of evaluation of tapers</span>
0074 
0075 Sc=zeros(length(findx),C,C);
0076 tn=mintime:win:maxtime-win;
0077 Nwins=length(tn);
0078 <span class="keyword">if</span> d==3, <span class="comment">% If there are multiple trials</span>
0079 <span class="keyword">for</span> iwin=1:Nwins,
0080     t=[tn(iwin) tn(iwin)+T];
0081     <span class="keyword">for</span> i=1:Ntr, 
0082         data1=data(:,i);
0083         data1=<a href="extractdatapt.html" class="code" title="function data=extractdatapt(data,t,offset)">extractdatapt</a>(data1,t,1); <span class="comment">% extract spike times in window,reset times to be relative to beginning of window</span>
0084         J1=<a href="mtfftpt.html" class="code" title="function [J,Msp,Nsp]=mtfftpt(data,tapers,nfft,t,f,findx)">mtfftpt</a>(data1,tapers,nfft,twin,f,findx);
0085         <span class="keyword">for</span> k=1:C,
0086             <span class="keyword">for</span> l=1:C,
0087                 spec=squeeze(mean(conj(J1(:,:,k)).*J1(:,:,l),2)); 
0088             Sc(:,k,l)=Sc(:,k,l)+spec;
0089             <span class="keyword">end</span>
0090         <span class="keyword">end</span>
0091     <span class="keyword">end</span>
0092 <span class="keyword">end</span>
0093 Sc=Sc/(Nwins*Ntr);
0094 <span class="keyword">end</span>
0095 
0096 <span class="keyword">if</span> d==2, <span class="comment">% only one trial</span>
0097 <span class="keyword">for</span> iwin=1:Nwins,
0098         data1=data(:,i);
0099         data1=<a href="extractdatapt.html" class="code" title="function data=extractdatapt(data,t,offset)">extractdatapt</a>(data1,t,1); <span class="comment">% extract spike times in window,reset times to be relative to beginning of window</span>
0100         J1=<a href="mtfftpt.html" class="code" title="function [J,Msp,Nsp]=mtfftpt(data,tapers,nfft,t,f,findx)">mtfftpt</a>(data1,tapers,nfft,twin,f,findx);
0101         <span class="keyword">for</span> k=1:C,
0102             <span class="keyword">for</span> l=1:C,
0103             Sc(:,k,l)=Sc(:,k,l)+squeeze(mean(conj(J1(:,:,k)).*J1(:,:,l),2));
0104             <span class="keyword">end</span>
0105         <span class="keyword">end</span>
0106 <span class="keyword">end</span>
0107 Sc=Sc/Nwins;
0108 <span class="keyword">end</span>
0109 
0110 Cmat=Sc;
0111 Sdiag=zeros(length(findx),C);
0112 <span class="keyword">for</span> k=1:C,
0113     Sdiag(:,k)=squeeze(Sc(:,k,k));
0114 <span class="keyword">end</span>
0115 
0116 <span class="keyword">for</span> k=1:C,
0117     <span class="keyword">for</span> l=1:C,
0118         Cmat(:,k,l)=Sc(:,k,l)./sqrt(abs(Sdiag(:,k).*Sdiag(:,l)));
0119     <span class="keyword">end</span>
0120 <span class="keyword">end</span>
0121 
0122 Ctot=zeros(length(findx),1); Cent=Ctot;
0123 Cvec=zeros(length(findx),C);
0124 <span class="keyword">for</span> i=1:length(findx),
0125     [u s]=svd(squeeze(Sc(i,:,:)));s=diag(s);
0126     Ctot(i)=s(1)/sum(s); Cent(i)=exp(mean(log(s.^2)))/mean(s.^2);             
0127     Cvec(i,:)=transpose(u(:,1));
0128 
0129 <span class="keyword">end</span>
0130</pre></div>
<hr><address>Generated on Fri 12-Aug-2011 11:36:15 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>